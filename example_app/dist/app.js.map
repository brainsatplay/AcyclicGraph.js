{
  "version": 3,
  "sources": ["../node_modules/fragelement/DOMElement.js", "../node_modules/acyclicgraph/acyclicgraph.js", "../src/components/acyclicgraph/graphnode.component.js", "../src/components/acyclicgraph/acyclicgraph.component.js", "../src/components/sequencer/seqnode.component.js", "../node_modules/anothersequencer/sequencer.js", "../src/components/sequencer/sequencer.component.js", "../src/components/canvasnode/canvasnode.component.js", "../src/components/component.js"],
  "sourcesContent": ["\r\nexport class DOMElement extends HTMLElement { \r\n\r\n    template = (props) => {return `<div> Custom Fragment Props: ${JSON.stringify(props)} </div>`}; //override the default template string by extending the class, or use options.template if calling the base class\r\n    props = {test:true};\r\n    useShadow = false; //can set to attach a shadow DOM instead (local styles)\r\n    \r\n    oncreate=undefined //(props) => {}  fires on element creation (e.g. to set up logic)\r\n    onresize=undefined //(props) => {} fires on window resize\r\n    ondelete=undefined //(props) => {} fires after element is deleted\r\n    onchanged=undefined //(props) => {} fires when props change\r\n\r\n    fragment = undefined;\r\n    attachedShadow = false;\r\n\r\n    obsAttributes=[\"props\",\"options\",\"onchanged\",\"onresize\",\"ondelete\",\"oncreate\",\"template\"]\r\n \r\n    get observedAttributes() {\r\n        return this.obsAttributes;\r\n    }\r\n\r\n    get obsAttributes() {\r\n        return this.obsAttributes;\r\n    }\r\n\r\n    set obsAttributes(att) {\r\n        if(typeof att === 'string') {\r\n            this.obsAttributes.push(att);\r\n        } else if (Array.isArray(att)) this.obsAttributes=att;\r\n    }\r\n\r\n    static get tag(){return this.name.toLowerCase()+'-'} //tagName, default 'classname-'. Set as a static variable for the internal addElement to reference\r\n\r\n    //add self or a specified class to the window which can be used via html like <custom-tag></custom-tag>\r\n    //will default be the classname with a '-' at the end if no tag supplied\r\n    static addElement(tag=this.tag,cls=this,extend=undefined) {\r\n        addCustomElement(cls,tag,extend)\r\n    }\r\n\r\n    attributeChangedCallback(name, old, val) {\r\n        if(name === 'onchanged') {\r\n            let onchanged = val;\r\n            if(typeof onchanged === 'string') onchanged = parseFunctionFromText(onchanged);\r\n            if(typeof onchanged === 'function') { \r\n                this.onchanged =  onchanged;\r\n                this.state.data.props = this.props;\r\n                this.state.unsubscribeTrigger('props'); //remove any previous subs\r\n                this.state.subscribeTrigger('props',this.onchanged);\r\n                let changed = new CustomEvent('changed', {detail: { props:this.props }});\r\n                this.state.subscribeTrigger('props',()=>{this.dispatchEvent(changed)});\r\n            }\r\n        }\r\n        else if(name === 'onresize') {\r\n            let onresize = val;\r\n            if(typeof onresize === 'string')  onresize = parseFunctionFromText(onresize);\r\n            if(typeof onresize === 'function') {\r\n                if(this.ONRESIZE) {\r\n                    try { window.removeEventListener('resize',this.ONRESIZE); } catch(err) {}\r\n                }\r\n                this.ONRESIZE = (ev) => { this.onresize(this.props); } \r\n                this.onresize = onresize;\r\n                window.addEventListener('resize',this.ONRESIZE);\r\n            }\r\n        }\r\n        else if(name === 'ondelete') {\r\n            let ondelete = val;\r\n            if(typeof ondelete === 'string') ondelete = parseFunctionFromText(ondelete);\r\n            if(typeof ondelete === 'function') { \r\n                this.ondelete = () => {\r\n                    if(this.ONRESIZE) window.removeEventListener('resize',this.ONRESIZE);\r\n                    this.state.unsubscribeTrigger('props');\r\n                    ondelete(this.props);\r\n                }\r\n            }\r\n        }\r\n        else if(name === 'oncreate') { \r\n            let oncreate = val;\r\n            if(typeof oncreate === 'string') oncreate = parseFunctionFromText(oncreate);\r\n            if(typeof oncreate === 'function') { \r\n                this.oncreate = oncreate;\r\n            }\r\n        }\r\n        else if(name === 'props') { //update the props, fires any onchanged stuff\r\n            let newProps = val;\r\n            if(typeof newProps === 'string') newProps = JSON.parse(newProps);\r\n\r\n            Object.assign(this.props,newProps);\r\n            this.state.setState({props:this.props});\r\n        }\r\n        else if(name === 'template') { //change the html template\r\n\r\n            let template = val;\r\n\r\n            this.template = options.template; //function or string;\r\n\r\n            if(typeof template === 'function') this.templateString = this.template(this.props); //can pass a function\r\n            else this.templateString = template;\r\n            \r\n            //render the new template\r\n            this.render(this.props);\r\n            let created = new CustomEvent('created', {detail: { props:this.props }});\r\n            this.dispatchEvent(created);\r\n\r\n        }\r\n        else { //arbitrary attributes\r\n            let parsed = val;\r\n            if(name.includes('eval_')) { // e.g. <custom-  eval_loginput=\"(input)=>{console.log(input);}\"></custom-> //now elm.loginput(input) should work\r\n                name = name.split('_')\r\n                name.shift()\r\n                name = name.join();\r\n                parsed = parseFunctionFromText(val);  \r\n            }\r\n            else if (typeof val === 'string') {\r\n                try {\r\n                    parsed = JSON.parse(val)\r\n                } catch (err) {\r\n                    parsed = val;\r\n                }\r\n            }\r\n            this[name] = parsed; // set arbitrary props \r\n            this.props[name] = parsed; //reflect it in the props object (to set props via attributes more easily)\r\n            //this.props[name] = val; //set arbitrary props via attributes\r\n        }\r\n    }\r\n\r\n    connectedCallback() {\r\n\r\n        // set initial props\r\n        let newProps = this.getAttribute('props');\r\n        if(typeof newProps === 'string') newProps = JSON.parse(newProps);\r\n\r\n        Object.assign(this.props,newProps);\r\n        this.state.setState({props:this.props});\r\n\r\n        //Observe arbitrary attributes\r\n        Array.from(this.attributes).forEach((att) => {\r\n            let name = att.name;\r\n            //console.log(name,this.getAttribute(name),this[name])\r\n            //get/set/observe arbitrary attributes\r\n            let parsed = att.value;\r\n            if(name.includes('eval_')) { // e.g. <custom-  eval_loginput=\"(input)=>{console.log(input);}\"></custom-> //now elm.loginput(input) should work\r\n                name = name.split('_')\r\n                name.shift()\r\n                name = name.join();\r\n                parsed = parseFunctionFromText(att.value);  \r\n            }\r\n            else if (typeof att.value === 'string') {\r\n                try {\r\n                    parsed = JSON.parse(att.value)\r\n                } catch (err) {\r\n                    parsed = att.value;\r\n                }\r\n            }\r\n            if(!this[name]) {\r\n                Object.defineProperties(\r\n                    this, att, {\r\n                        value:parsed,\r\n                        writable:true,\r\n                        get() { return this[name]; },\r\n                        set(val) { this.setAttribute(name, val); }\r\n                    }\r\n                )\r\n            }\r\n            this[name] = parsed;\r\n            this.props[name] = parsed; //set on props too (e.g. to more easily modify initial conditions without stringifying an object)\r\n            this.obsAttributes.push(name);\r\n            \r\n            //console.log(this.observedAttributes);\r\n        });\r\n\r\n        let resizeevent = new CustomEvent('resized', {detail: { props:this.props }});\r\n        let changed = new CustomEvent('changed', {detail: { props:this.props }});\r\n        let deleted = new CustomEvent('deleted', {detail: { props:this.props }});\r\n        let created = new CustomEvent('created', {detail: { props:this.props }});\r\n        //now we can add event listeners for our custom events\r\n\r\n        this.render(this.props);\r\n        this.dispatchEvent(created);\r\n\r\n        this.state.subscribeTrigger('props',()=>{this.dispatchEvent(changed)});\r\n\r\n        if(typeof this.onresize === 'function') {\r\n            if(this.ONRESIZE) {\r\n                try { window.removeEventListener('resize',this.ONRESIZE); } catch(err) {}\r\n            }\r\n            this.ONRESIZE = (ev) => { this.onresize(this.props); } \r\n            window.addEventListener('resize',this.ONRESIZE);       \r\n        }\r\n\r\n        if(typeof this.ondelete === 'function') {\r\n            this.ondelete = (props=this.props) => {\r\n                if(this.ONRESIZE) window.removeEventListener('resize',this.ONRESIZE);\r\n                this.state.unsubscribeTrigger('props');\r\n                ondelete(props);\r\n            }\r\n        }\r\n\r\n        if(typeof this.onchanged === 'function') {\r\n            this.state.data.props = this.props;\r\n            this.state.subscribeTrigger('props',this.onchanged);\r\n        }\r\n\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    get props() {\r\n        return this.props;\r\n    } \r\n\r\n    set props(newProps={}) {\r\n        this.setAttribute('props',newProps);\r\n    }\r\n\r\n    get template() {\r\n        return this.template;\r\n    } \r\n\r\n    set template(template) {\r\n        this.setAttribute('template',template);\r\n    }\r\n\r\n    get render() {\r\n        return this.render;\r\n    }\r\n\r\n    get delete() {\r\n        return this.delete;\r\n    }\r\n\r\n    get state() {\r\n        return this.state;\r\n    }\r\n\r\n    //past tense just so it can't conflict with onchange\r\n    get onchanged() {\r\n        return this.onchanged;\r\n    } \r\n\r\n    set onchanged(onchanged) {\r\n        this.setAttribute('onchanged',onchanged);\r\n    }\r\n\r\n    get onresize() {\r\n        return this.props;\r\n    } \r\n\r\n    set onresize(onresize) {\r\n        this.setAttribute('onresize',onresize);\r\n    }\r\n\r\n    get ondelete() {\r\n        return this.props;\r\n    } \r\n\r\n    set ondelete(ondelete) {\r\n        this.setAttribute('ondelete',ondelete);\r\n    }\r\n\r\n    get oncreate() {\r\n        return this.oncreate;\r\n    } \r\n\r\n    set oncreate(oncreate) {\r\n        this.setAttribute('oncreated',oncreate);\r\n    }\r\n\r\n    delete = () => { //deletes self from the DOM\r\n        this.fragment = undefined;\r\n        this.remove();\r\n        if(this.ondelete) this.ondelete(this.props);\r\n    };\r\n\r\n    render = (props=this.props) => {\r\n\r\n        if(typeof this.template === 'function') this.templateString = this.template(props); //can pass a function\r\n        else this.templateString = this.template;\r\n\r\n        //this.innerHTML = this.templateString;\r\n\r\n        const t = document.createElement('template');\r\n        t.innerHTML = this.templateString;\r\n        const fragment = t.content;\r\n        if(this.fragment) { //will reappend the fragment without reappending the whole node if already rendered once\r\n            if(this.useShadow) {\r\n                this.shadowRoot.removeChild(this.fragment);\r\n            }   \r\n            else this.removeChild(this.fragment); \r\n        }\r\n        this.fragment = fragment;\r\n        if(this.useShadow) {\r\n            if(!this.attachedShadow) this.attachShadow({mode:'open'});\r\n            this.shadowRoot.appendChild(fragment); //now you need to use the shadowRoot.querySelector etc.\r\n        }   \r\n        else this.appendChild(fragment);\r\n        \r\n        if(this.oncreate) this.oncreate(props); //set scripted behaviors\r\n    }\r\n\r\n    state = {\r\n        pushToState:{},\r\n        data:{},\r\n        triggers:{},\r\n        setState(updateObj){\r\n            Object.assign(this.pushToState,updateObj);\r\n\r\n            if(Object.keys(this.triggers).length > 0) {\r\n                // Object.assign(this.data,this.pushToState);\r\n                for (const prop of Object.getOwnPropertyNames(this.triggers)) {\r\n                    if(this.pushToState[prop]) {\r\n                        this.data[prop] = this.pushToState[prop]\r\n                        delete this.pushToState[prop];\r\n                        this.triggers[prop].forEach((obj)=>{\r\n                            obj.onchanged(this.data[prop]);\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return this.pushToState;\r\n        },\r\n        subscribeTrigger(key,onchanged=(res)=>{}){\r\n            if(key) {\r\n                if(!this.triggers[key]) {\r\n                    this.triggers[key] = [];\r\n                }\r\n                let l = this.triggers[key].length;\r\n                this.triggers[key].push({idx:l, onchanged:onchanged});\r\n                return this.triggers[key].length-1;\r\n            } else return undefined;\r\n        },\r\n        unsubscribeTrigger(key,sub){\r\n            let idx = undefined;\r\n            let triggers = this.triggers[key]\r\n            if (triggers){\r\n                if(!sub) delete this.triggers[key];\r\n                else {\r\n                    let obj = triggers.find((o)=>{\r\n                        if(o.idx===sub) {return true;}\r\n                    });\r\n                    if(obj) triggers.splice(idx,1);\r\n                    return true;\r\n                }\r\n            }\r\n        },\r\n        subscribeTriggerOnce(key=undefined,onchanged=(value)=>{}) {\r\n            let sub;\r\n            let changed = (value) => {\r\n                onchanged(value);\r\n                this.unsubscribeTrigger(key,sub);\r\n            }\r\n\r\n            sub = this.subscribeTrigger(key,changed);\r\n        }\r\n    }\r\n}\r\n\r\n//extend the DOMElement class with an new name, this name determines the element name (always lower case in the html regardless of class name cases)\r\nexport function addCustomElement(cls, tag, extend=null) {\r\n    if(extend) {\r\n        if(tag) window.customElements.define(tag, cls, {extends:extend});\r\n        else window.customElements.define(cls.name.toLowerCase()+'-',cls, {extends:extend});\r\n    }\r\n    else {\r\n        if(tag) window.customElements.define(tag, cls);\r\n        else window.customElements.define(cls.name.toLowerCase()+'-',cls);\r\n    }\r\n}\r\n\r\nexport function randomId(tag='') {\r\n    return tag+Math.floor(Math.random()*1000000000000000);\r\n}\r\n\r\n// Proper DOM fragment implementation which also creates customElements you can use like <so></so>. High HTML5 performance via template fragments\r\nexport function parseFunctionFromText(method) {\r\n    //Get the text inside of a function (regular or arrow);\r\n    let getFunctionBody = (methodString) => {\r\n    return methodString.replace(/^\\W*(function[^{]+\\{([\\s\\S]*)\\}|[^=]+=>[^{]*\\{([\\s\\S]*)\\}|[^=]+=>(.+))/i, '$2$3$4');\r\n    }\r\n\r\n    let getFunctionHead = (methodString) => {\r\n    let startindex = methodString.indexOf(')');\r\n    return methodString.slice(0, methodString.indexOf('{',startindex) + 1);\r\n    }\r\n\r\n    let newFuncHead = getFunctionHead(method);\r\n    let newFuncBody = getFunctionBody(method);\r\n\r\n    let newFunc;\r\n    try{\r\n        if (newFuncHead.includes('function ')) {\r\n            let varName = newFuncHead.split('(')[1].split(')')[0]\r\n            newFunc = new Function(varName, newFuncBody);\r\n        } else {\r\n            if(newFuncHead.substring(0,6) === newFuncBody.substring(0,6)) {\r\n                //newFuncBody = newFuncBody.substring(newFuncHead.length);\r\n                let varName = newFuncHead.split('(')[1].split(')')[0]\r\n                //console.log(varName, newFuncHead ,newFuncBody);\r\n                newFunc = new Function(varName, newFuncBody.substring(newFuncBody.indexOf('{')+1,newFuncBody.length-1));\r\n            }\r\n            else {\r\n                try {\r\n                    newFunc = eval(newFuncHead + newFuncBody + \"}\");\r\n                } catch(err) {\r\n                    newFunc = eval(method); //try just evaluating the method\r\n                }\r\n            }\r\n        }\r\n    }\r\n    catch (err) {}\r\n\r\n    return newFunc;\r\n\r\n}\r\n\r\n", "//just a more typical hierarchical graph tree with back and forward prop and arbitrary \r\n// go-here-do-that utilities. Create an object node tree and make it do... things \r\n// same setup as sequencer but object/array/tag only (no functions), and can add arbitrary properties to mutate on objects\r\n// or propagate to children/parents with utility calls that get added to the objects\r\n//Joshua Brewster and Garrett Flynn AGPLv3.0\r\n\r\n\r\n/*\r\n\r\nlet tree = { //top level should be an object, children can be arrays of objects\r\n    tag:'top',\r\n    operator:(input,node,origin)=>{\r\n        if(typeof input === 'object') {\r\n            if(input?.x) node.x = input.x; \r\n            if(input?.y) node.y = input.y;\r\n            if(input?.z) node.z = input.z;\r\n            console.log('top node, input:', input);\r\n        }\r\n        return input;\r\n    }, //input is the previous result if passed from another node. node is 'this' node, origin is the previous node if passed\r\n    forward:true, //forward prop: returned outputs from the operator are passed to children operator(s)\r\n    //backward:true, //backprop: returned outputs from the operator are passed to the parent operator\r\n    x:3, //arbitrary properties available on the node variable in the operator \r\n    y:2,\r\n    z:1,\r\n    children:{ //object, array, or tag. Same as the 'next' tag in Sequencer.js\r\n        tag:'next', //tagged nodes get added to the node map by name, they must be unique! non-tagged nodes are only referenced internally e.g. in call trees\r\n        operator:(input,node,origin)=>{\r\n            if(origin.x) { //copy over the coordinates\r\n                node.x = origin.x;\r\n                node.y = origin.y;\r\n                node.z = origin.z;\r\n            }\r\n            console.log('next node \\n parent node:',node,'\\ninput',input);\r\n        }, // if you use a normal function operator(input,node,origin){} then you can use 'this' reference instead of 'node', while 'node' is more flexible for arrow functions etc.\r\n        //etc..\r\n        delay:500,\r\n        repeat:3\r\n    },\r\n    delay:1000//, //can timeout the operation\r\n    //frame:true //can have the operation run via requestAnimationFrame (throttling)\r\n    //repeat:3 //can repeat an operator, or use \"recursive\" for the same but passing the node's result back in\r\n};\r\n\r\n\r\nlet graph = new AcyclicGraph();\r\ngraph.addNode(tree);\r\n\r\ngraph.run(tree.tag,{x:4,y:5,z:6});\r\n\r\neach node in the tree becomes a GraphNode object\r\n\r\n*/\r\n//TODO: try to reduce the async stack a bit for better optimization, though in general it is advantageous matter as long as node propagation isn't \r\n//   relied on for absolute maximal performance concerns, those generally require custom solutions e.g. matrix math or clever indexing, but this can be used as a step toward that.\r\n\r\n//a graph representing a callstack of nodes which can be arranged arbitrarily with forward and backprop or propagation to wherever\r\nexport const state = {\r\n    pushToState:{},\r\n    data:{},\r\n    triggers:{},\r\n    setState(updateObj){\r\n        Object.assign(this.pushToState,updateObj);\r\n\r\n        if(Object.keys(this.triggers).length > 0) {\r\n            // Object.assign(this.data,this.pushToState);\r\n            for (const prop of Object.getOwnPropertyNames(this.triggers)) {\r\n                if(this.pushToState[prop]) {\r\n                    this.data[prop] = this.pushToState[prop]\r\n                    delete this.pushToState[prop];\r\n                    this.triggers[prop].forEach((obj)=>{\r\n                        obj.onchange(this.data[prop]);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        return this.pushToState;\r\n    },\r\n    subscribeTrigger(key,onchange=(res)=>{}){\r\n        if(key) {\r\n            if(!this.triggers[key]) {\r\n                this.triggers[key] = [];\r\n            }\r\n            let l = this.triggers[key].length;\r\n            this.triggers[key].push({idx:l, onchange:onchange});\r\n            return this.triggers[key].length-1;\r\n        } else return undefined;\r\n    },\r\n    unsubscribeTrigger(key,sub){\r\n        let idx = undefined;\r\n        let triggers = this.triggers[key]\r\n        if (triggers){\r\n            if(!sub) delete this.triggers[key];\r\n            else {\r\n                let obj = triggers.find((o)=>{\r\n                    if(o.idx===sub) {return true;}\r\n                });\r\n                if(obj) triggers.splice(idx,1);\r\n                return true;\r\n            }\r\n        }\r\n    },\r\n    subscribeTriggerOnce(key=undefined,onchange=(value)=>{}) {\r\n        let sub;\r\n        let changed = (value) => {\r\n            onchange(value);\r\n            this.unsubscribeTrigger(key,sub);\r\n        }\r\n\r\n        sub = this.subscribeTrigger(key,changed);\r\n    }\r\n}\r\n\r\nexport class AcyclicGraph {\r\n    state = state;\r\n    nodes = new Map()\r\n    nNodes = 0\r\n\r\n    constructor() {}\r\n\r\n    //convert child objects to nodes\r\n    convertChildrenToNodes(n) {\r\n        n.convertChildrenToNodes(n);\r\n    }\r\n\r\n    //converts all children nodes and tag references to graphnodes also\r\n    addNode(node={}) {\r\n        let converted = new GraphNode(node,undefined,this); \r\n        return converted;\r\n    }\r\n\r\n    getNode(tag) {\r\n        return this.nodes.get(tag);\r\n    }\r\n\r\n    //Should create a sync version with no promises (will block but be faster)\r\n    run(node,input,origin) {\r\n        if(typeof node === 'string') node = this.nodes.get(node);\r\n        if(node)\r\n            return node.run(node,input,origin)\r\n        else return undefined;\r\n    }\r\n\r\n    removeTree(node) {\r\n        if(typeof node === 'string') node = this.nodes.get(node);\r\n        if(node) {\r\n            function recursivelyRemove(node) {\r\n                if(node.children) {\r\n                    if(Array.isArray(node.children)) {\r\n                        node.children.forEach((c)=>{\r\n                            if(c.stopNode) c.stopNode();\r\n                            if(c.tag) {\r\n                                if(this.nodes.get(c.tag)) this.nodes.delete(c.tag);\r\n                            }\r\n                            this.nodes.forEach((n) => {\r\n                                if(n.nodes.get(c.tag)) n.nodes.delete(c.tag);\r\n                            });\r\n                            recursivelyRemove(c);\r\n                        })\r\n                    }\r\n                    else if(typeof node.children === 'object') {\r\n                        if(node.stopNode) node.stopNode();\r\n                        if(node.tag) {\r\n                            if(this.nodes.get(node.tag)) this.nodes.delete(node.tag);\r\n                        }\r\n                        this.nodes.forEach((n) => {\r\n                            if(n.nodes.get(node.tag)) n.nodes.delete(node.tag);\r\n                        });\r\n                        recursivelyRemove(node);\r\n                    }\r\n                }\r\n            }\r\n            if(node.stopNode) node.stopNode();\r\n            if(node.tag) {\r\n                this.nodes.delete(node.tag);\r\n                this.nodes.forEach((n) => {\r\n                    if(n.nodes.get(node.tag)) n.nodes.delete(node.tag);\r\n                });\r\n                recursivelyRemove(node);\r\n            }\r\n        }\r\n    }\r\n\r\n    removeNode(node) {\r\n        if(typeof node === 'string') node = this.nodes.get(node);\r\n        if(node?.tag) this.nodes.delete(node.tag);\r\n        if(node?.tag) {\r\n            if(this.nodes.get(node.tag)) \r\n            {\r\n                this.nodes.delete(node.tag);\r\n                if(this.graph) this.graph.nodes.delete(node.tag);\r\n                this.nodes.forEach((n) => {\r\n                    if(n.nodes.get(node.tag)) n.nodes.delete(node.tag);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    appendNode(node={}, parentNode) {\r\n        parentNode.addChildren(node);\r\n    }\r\n\r\n    async callParent(node, input, origin=node, cmd) {\r\n        if(node?.parent) {\r\n            return await node.callParent(input, node.parent, origin, cmd);\r\n        }\r\n    }\r\n\r\n    async callChildren(node, input, origin=node, cmd, idx) {\r\n        if(node?.children) {\r\n            return await node.callChildren(input, origin, cmd, idx);\r\n        }\r\n    }\r\n\r\n    subscribe(tag,callback=(res)=>{}) {\r\n        return this.state.subscribeTrigger(tag,callback);\r\n    }\r\n\r\n    unsubscribe(tag,sub) {\r\n        this.state.unsubscribeTrigger(tag,sub);\r\n    }\r\n\r\n}\r\n\r\n//the utilities in this class can be referenced in the operator after setup for more complex functionality\r\n//node functionality is self-contained, use a graph for organization\r\nexport class GraphNode {\r\ntag;\r\nparent;\r\nchildren;\r\ngraph;\r\nstate = state; //shared trigger state\r\nnodes = new Map();\r\n\r\nconstructor(properties={}, parentNode, graph) {\r\n    if(!properties.tag && graph) properties.tag = `node${graph.nNodes}`; //add a sequential id to find the node in the tree \r\n    else if(!properties.tag) properties.tag = `node${Math.floor(Math.random()*10000000000)}`; //add a random id for the top index if none supplied\r\n    Object.assign(this,properties); //set the node's props as this\r\n    this.parent=parentNode;\r\n    this.graph=graph;\r\n\r\n    if(graph) {\r\n        graph.nNodes++;\r\n        graph.nodes.set(properties.tag,this);\r\n    }\r\n\r\n    if(this.children) this.convertChildrenToNodes(this);\r\n}\r\n\r\n//I/O scheme for this node\r\noperator(input,node=this,origin,cmd){\r\n    return input;\r\n}\r\n\r\n//run the operator\r\nasync runOp(input,node=this,origin,cmd) {\r\n    let result = await this.operator(input,node,origin,cmd);\r\n    if(this.tag) this.state.setState({[this.tag]:result});\r\n    return result;\r\n}\r\n\r\n//runs the node sequence\r\n//Should create a sync version with no promises (will block but be faster)\r\nrun(node=this,input,origin) {\r\n    if(typeof node === 'string') \r\n        {\r\n            let fnd;\r\n            if(this.graph) fnd = this.graph.nodes.get(node);\r\n            if(!fnd) fnd = this.nodes.get(node);\r\n            node = fnd;\r\n            if(!node) return undefined;\r\n        }\r\n\r\n    return new Promise(async (resolve) => {\r\n        if(node) {\r\n            let run = (node, inp, tick=0) => {\r\n                return new Promise (async (r) => {\r\n                    tick++;\r\n                    let res = await node.runOp(inp,node,origin);\r\n                    if(typeof node.repeat === 'number') {\r\n                        while(tick < node.repeat) {\r\n                            if(node.delay) {\r\n                                setTimeout(async ()=>{\r\n                                    r(await run(node,inp,tick));\r\n                                },node.delay);\r\n                                break;\r\n                            } else if (node.frame && requestAnimationFrame) {\r\n                                requestAnimationFrame(async ()=>{\r\n                                    r(await run(node,inp,tick));\r\n                                });\r\n                                break;\r\n                            }\r\n                            else res = await node.runOp(inp,node,origin);\r\n                            tick++;\r\n                        }\r\n                        if(tick === node.repeat) {\r\n                            r(res);\r\n                            return;\r\n                        }\r\n                    } else if(typeof node.recursive === 'number') {\r\n                        \r\n                        while(tick < node.recursive) {\r\n                            if(node.delay) {\r\n                                setTimeout(async ()=>{\r\n                                    r(await run(node,res,tick));\r\n                                },node.delay);\r\n                                break;\r\n                            } else if (node.frame && requestAnimationFrame) {\r\n                                requestAnimationFrame(async ()=>{\r\n                                    r(await run(node,res,tick));\r\n                                });\r\n                                break;\r\n                            }\r\n                            else res = await node.runOp(res,node,origin);\r\n                            tick++;\r\n                        }\r\n                        if(tick === node.recursive) {\r\n                            r(res);\r\n                            return;\r\n                        }\r\n                    } else {\r\n                        r(res);\r\n                        return;\r\n                    }\r\n                });\r\n            }\r\n\r\n\r\n            let runnode = async () => {\r\n\r\n                let res = await run(node,input); //repeat/recurse before moving on to the parent/child\r\n\r\n                if(node.backward && node.parent) {\r\n                    await this.runNode(node.parent,res,node);\r\n                }\r\n                if(node.children && node.forward) {\r\n                    if(Array.isArray(node.children)) {\r\n                        for(let i = 0; i < node.children.length; i++) {\r\n                            await this.runNode(node.children[i],res,node);\r\n                        }\r\n                    }\r\n                    else await this.runNode(node.children,res,node);\r\n                }\r\n\r\n                //can add an animationFrame coroutine, one per node //because why not\r\n                if(node.animate && !node.isAnimating) {\r\n                    this.runAnimation(input,node,origin);\r\n                }\r\n\r\n                //can add an infinite loop coroutine, one per node, e.g. an internal subroutine\r\n                if(typeof node.loop === 'number' && !node.isLooping) {\r\n                    this.runLoop(input,node,origin);\r\n                }\r\n                \r\n                return res;\r\n            }\r\n\r\n            if(node.delay) {\r\n                setTimeout(async ()=>{\r\n                    resolve(await runnode());\r\n                },node.delay);\r\n            } else if (node.frame && requestAnimationFrame) {\r\n                requestAnimationFrame(async ()=>{\r\n                    resolve(await runnode());\r\n                });\r\n            } else {\r\n                resolve(await runnode());\r\n            }\r\n            \r\n        }\r\n        else resolve(undefined);\r\n    });\r\n}\r\n\r\nrunAnimation(input,node=this,origin) {\r\n    //can add an animationFrame coroutine, one per node //because why not\r\n    if(node.animate && !node.isAnimating) {\r\n        node.isAnimating = true;\r\n        let anim = async () => {\r\n            if(node.isAnimating) {\r\n                await node.runOp( \r\n                    input,\r\n                    node,\r\n                    origin,\r\n                    'animate'\r\n                );\r\n                requestAnimationFrame(async ()=>{await anim();});\r\n            }\r\n        }\r\n        requestAnimationFrame(anim);\r\n    }\r\n}\r\n\r\nrunLoop(input,node=this,origin) {\r\n    //can add an infinite loop coroutine, one per node, e.g. an internal subroutine\r\n    if(typeof node.loop === 'number' && !node.isLooping) {\r\n        node.isLooping = true;\r\n        let loop = async () => {\r\n            if(node.looping)  {\r\n                await node.runOp( \r\n                    input,\r\n                    node,\r\n                    origin,\r\n                    'loop'\r\n                );\r\n                setTimeout(async ()=>{await loop();},node.loop);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//this is the i/o handler, or the 'main' function for this node to propagate results. The origin is the node the data was propagated from\r\nsetOperator(operator=function operator(input,node=this,origin,cmd){return input;}) {\r\n    this.operator = operator;\r\n}\r\n\r\nsetParent(parent) { \r\n    this.parent = parent;\r\n}\r\n\r\nsetChildren(children) {\r\n    this.children = children;\r\n}\r\n\r\nremoveTree(node) {\r\n    if(typeof node === 'string') node = this.nodes.get(node);\r\n    if(node) {\r\n        function recursivelyRemove(node) {\r\n            if(node.children) {\r\n                if(Array.isArray(node.children)) {\r\n                    node.children.forEach((c)=>{\r\n                        if(c.stopNode) c.stopNode();\r\n                        if(c.tag) {\r\n                            if(this.nodes.get(c.tag)) this.nodes.delete(c.tag);\r\n                        }\r\n                        this.nodes.forEach((n) => {\r\n                            if(n.nodes.get(c.tag)) n.nodes.delete(c.tag);\r\n                        });\r\n                        recursivelyRemove(c);\r\n                    })\r\n                }\r\n                else if(typeof node.children === 'object') {\r\n                    if(node.stopNode) node.stopNode();\r\n                    if(node.tag) {\r\n                        if(this.nodes.get(node.tag)) this.nodes.delete(node.tag);\r\n                    }\r\n                    this.nodes.forEach((n) => {\r\n                        if(n.nodes.get(node.tag)) n.nodes.delete(node.tag);\r\n                    });\r\n                    recursivelyRemove(node);\r\n                }\r\n            }\r\n        }\r\n        if(node.stopNode) node.stopNode();\r\n        if(node.tag) {\r\n            this.nodes.delete(node.tag);\r\n            this.nodes.forEach((n) => {\r\n                if(n.nodes.get(node.tag)) n.nodes.delete(node.tag);\r\n            });\r\n            recursivelyRemove(node);\r\n            if(this.graph) this.graph.nodes.removeTree(node); //remove from parent graph too \r\n        }\r\n    }\r\n}\r\n\r\n//converts all children nodes and tag references to graphnodes also\r\naddNode(node={}) {\r\n    let converted = new GraphNode(node,this,this.graph); \r\n    this.nodes.set(converted);\r\n    if(this.graph) this.graph.nodes.set(converted);\r\n    return converted;\r\n}\r\n\r\nremoveNode(node) {\r\n    if(typeof node === 'string') node = this.nodes.get(node);\r\n    if(node?.tag) this.nodes.delete(node.tag);\r\n    if(node?.tag) {\r\n        if(this.nodes.get(node.tag)) \r\n        {\r\n            this.nodes.delete(node.tag);\r\n            if(this.graph) this.graph.nodes.delete(node.tag);\r\n            this.nodes.forEach((n) => {\r\n                if(n.nodes.get(node.tag)) n.nodes.delete(node.tag);\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nappendNode(node, parentNode=this) {\r\n    if(typeof node === 'string') node = this.nodes.get(node);\r\n    if(node) parentNode.addChildren(node);\r\n}\r\n\r\ngetNode(tag) {\r\n    return this.nodes.get(tag);\r\n}\r\n\r\n//Should create a sync version with no promises (will block but be faster)\r\nrunNode(node,input,origin) {\r\n    if(typeof node === 'string') node = this.nodes.get(node);\r\n    if(node)\r\n        return node.run(node,input,origin)\r\n    else return undefined;\r\n}\r\n\r\n//stop any loops\r\nstopLooping() {\r\n    node.isLooping = false;\r\n}\r\n\r\nstopAnimating() {\r\n    node.isAnimating = false;\r\n}\r\n\r\nstopNode() {\r\n    this.stopAnimating();\r\n    this.stopLooping();\r\n}\r\n\r\n//append child\r\naddChildren(children) {\r\n    if(!this.children) this.children = [];\r\n    if(!Array.isArray(this.children) && this.children) this.children = [this.children];\r\n    else if(Array.isArray(children)) this.children.push(...children);\r\n    else this.children.push(children);\r\n}\r\n\r\nconvertChildrenToNodes(n=this) {\r\n    if(n.children?.name === 'GraphNode') { \r\n        if(!this.graph?.nodes.get(n.tag)) this.graph.nodes.set(n.tag);\r\n        if(!this.nodes.get(n.tag)) this.nodes.set(n.tag); \r\n    }\r\n    else if (Array.isArray(n.children)) {\r\n        for(let i = 0; i < n.children.length; i++) {\r\n            if(n.children[i].name === 'GraphNode') { \r\n                if(!this.graph?.nodes.get(n.children[i].tag)) this.graph.nodes.set(n.children[i].tag);\r\n                if(!this.nodes.get(n.children[i].tag)) this.nodes.set(n.children[i].tag);\r\n                continue; \r\n            }\r\n            else if(typeof n.children[i] === 'object') {\r\n                n.children[i] = new GraphNode(n.children[i],n,this.graph);\r\n                this.nodes.set(n.children[i].tag);\r\n                this.convertChildrenToNodes(n.children[i]);\r\n            } \r\n            else if (typeof n.children[i] === 'string') {\r\n                if(this.graph) {\r\n                    n.children[i] = this.graph.getNode(n.children[i]); //try graph scope\r\n                    if(!this.nodes.get(n.children[i].tag)) this.nodes.set(n.children[i]);\r\n                }\r\n                if(!n.children[i]) n.children[i] = this.nodes.get(n.children[i]); //try local scope\r\n            }\r\n            \r\n        }\r\n    }\r\n    else if(typeof n.children === 'object') {\r\n        n.children = new GraphNode(n.children,n,this.graph);\r\n        this.nodes.set(n.children.tag);\r\n        this.convertChildrenToNodes(n.children);\r\n    } \r\n    else if (typeof n.children === 'string') {\r\n        if(this.graph) {\r\n            n.children = this.graph.getNode(n.children); //try graph scope\r\n            if(!this.nodes.get(n.children.tag)) this.nodes.set(n.children);\r\n        }\r\n        if(!n.children) n.children = this.nodes.get(n.children); //try local scope\r\n    }\r\n    return n.children;\r\n}\r\n\r\n//Call parent node operator directly\r\nasync callParent(input, origin=this, cmd){\r\n    if(typeof this.parent?.operator === 'function') return await this.parent.runOp(input,this.parent,origin, cmd);\r\n}\r\n\r\nasync callChildren(input, origin=this, cmd, idx){\r\n    let result;\r\n    if(Array.isArray(this.children)) {\r\n        if(idx) result = await this.children[idx]?.runOp(input,this.children[idx],origin,cmd);\r\n        else {\r\n            result = [];\r\n            for(let i = 0; i < this.children.length; i++) {\r\n                result.push(await this.children[idx]?.runOp(input,this.children[idx],origin,cmd));\r\n            } \r\n        }\r\n    } else if(this.children) {\r\n        result = await this.children.runOp(input,this.children,origin,cmd);\r\n    }\r\n    return result;\r\n}\r\n\r\nsetProps(props={}) {\r\n    Object.assign(this,props);\r\n}\r\n\r\nsubscribe(tag=this.tag,callback=(res)=>{}) {\r\n    return this.state.subscribeTrigger(tag,callback);\r\n}\r\n\r\nunsubscribe(tag=this.tag,sub) {\r\n    this.state.unsubscribeTrigger(tag,sub);\r\n}\r\n\r\n}\r\n\r\n\r\n// exports.AcyclicGraph = AcyclicGraph;\r\n// exports.GraphNode = GraphNode;\r\n\r\n", "\r\nimport {DOMElement, addCustomElement} from 'fragelement';\r\n\r\nimport {GraphNode} from 'acyclicgraph'\r\n\r\nlet component = require('./graphnode.component.html');\r\n\r\n//See: https://github.com/brainsatplay/domelement\r\nexport class NodeDiv extends DOMElement {\r\n    props={\r\n        operator:(\r\n            input, //input, e.g. output from another node\r\n            node,  //'this' node\r\n            origin, //origin node\r\n            cmd    //e.g. 'loop' or 'animate' will be defined if the operator is running on the loop or animate routines, needed something. Can define more commands but you might as well use an object in input for that. \r\n        )=>{ console.log(input); return input; }, //Operator to handle I/O on this node. Returned inputs can propagate according to below settings\r\n        forward:true, //pass output to child nodes\r\n        backward:false, //pass output to parent node\r\n        children:undefined, //child node(s), can be tags of other nodes, properties objects like this, or graphnodes, or null\r\n        delay:false, //ms delay to fire the node\r\n        repeat:false, // set repeat as an integer to repeat the input n times\r\n        recursive:false, //or set recursive with an integer to pass the output back in as the next input n times\r\n        animate:false, //true or false\r\n        loop:undefined, //milliseconds or false\r\n        tag:undefined, //generated if not specified, or use to get another node by tag instead of generating a new one\r\n        input:undefined,// can set on the attribute etc\r\n        graph:undefined, //parent AcyclicGraph instance, can set manually or via enclosing acyclic-graph div\r\n        node:undefined, //GraphNode instance, can set manually or as a string to grab a node by tag (or use tag)\r\n    }; //can specify properties of the element which can be subscribed to for changes.\r\n\r\n    input_delay=1 //onload runNode delay for graph nodes to run operations on inputs, they will not recognize their children otherwise as the DOM loads\r\n\r\n    //set the template string or function (which can input props to return a modified string)\r\n    template=component;\r\n\r\n    //gotta customize this a little from the default DOMElement\r\n \r\n    render = (props=this.props) => {\r\n\r\n        if(typeof this.template === 'function') this.templateString = this.template(props); //can pass a function\r\n        else this.templateString = this.template;\r\n\r\n        //this.innerHTML = this.templateString;\r\n\r\n        const t = document.createElement('template');\r\n        t.innerHTML = this.templateString;\r\n        const fragment = t.content;\r\n        if(this.fragment) { //will reappend the fragment without reappending the whole node if already rendered once\r\n            this.removeChild(this.fragment); \r\n        }\r\n        this.fragment = fragment;\r\n        this.appendChild(fragment);\r\n        \r\n        \r\n        //add this here which will run a routine AFTER rendering so the elements can be updated\r\n        this.setupNode(this.props);\r\n        if(this.props.input) { //e.g. run the node on input\r\n            setTimeout(async()=>{\r\n                this.props.node.runNode(this.props.node,this.props.input,this.props.graph); //run the inputs on the nodes once the children are loaded on the DOM so things propagate correctly\r\n            },\r\n            this.input_delay //makes sure children are loaded (e.g. on a DOM with a lot of loading, should add some execution delay to anticipate it as initial nodes are not aware of later-rendered nodes on the DOM)\r\n            );\r\n        }\r\n        if(this.oncreate) this.oncreate(props); //set scripted behaviors\r\n    }\r\n\r\n    setupNode(props) {\r\n        let parent = this.parentNode;\r\n        if(parent.props?.operator) { //has operator, this is a graph-node (in case you extend it with a new tagName)\r\n            props.parentNode = parent;\r\n        }\r\n        if(!props.graph) {   \r\n            while(!parent.props.nodes) { //has nodes prop, is an acyclic-graph\r\n                // console.log(parent)\r\n                // console.log(parent.tagName)\r\n                if(parent.constructor.name === 'HTMLBodyElement' || parent.constructor.name === 'HTMLHeadElement' || parent.constructor.name === 'HTMLHtmlElement' || parent.constructor.name === 'HTMLDocument') {\r\n                    console.error(\"No AcyclicGraph Found\")\r\n                    break;\r\n                }\r\n                parent = parent.parentNode;\r\n            }\r\n            if(parent.props?.nodes) {\r\n                props.graph = parent.props.graph;\r\n                props.input_delay = parent.props.input_delay;\r\n            }\r\n        }\r\n        if(this.id && !props.tag) props.tag = this.id;\r\n\r\n        if(props.graph && !props.node && props.tag) props.node = props.graph.nodes.get(props.tag); //can try to get graph nodes by id or tag\r\n        else if(props.graph && typeof props.node === 'string') props.node = props.graph.nodes.get(props.node); //can try to get graph nodes by id or tag\r\n        \r\n        if(!props.node) props.node = new GraphNode(props, parent.node, props.graph); //you could pass a graphnode \r\n\r\n        props.tag = props.node.tag;\r\n        if(!this.id) this.id = props.tag;\r\n\r\n        if(props.parentNode) {\r\n            props.parentNode.props.node?.addChildren(props.node);\r\n        }\r\n    }\r\n\r\n    \r\n    //DOMElement custom callbacks:\r\n    //oncreate=(props)=>{} //after rendering\r\n    //onresize=(props)=>{} //on window resize\r\n    //onchanged=(props)=>{} //on props changed\r\n    //ondelete=(props)=>{} //on element deleted. Can remove with this.delete() which runs cleanup functions\r\n}\r\n\r\n//window.customElements.define('custom-', Custom);\r\n\r\naddCustomElement(NodeDiv,'graph-node');\r\n", "\r\nimport {DOMElement, addCustomElement} from 'fragelement';\r\n\r\nimport {AcyclicGraph} from 'acyclicgraph'\r\n\r\nlet component = require('./acyclicgraph.component.html');\r\n\r\n//See: https://github.com/brainsatplay/domelement\r\nexport class Graph extends DOMElement {\r\n    props={\r\n        graph:new AcyclicGraph(),\r\n        nodes:[]\r\n    } //can specify properties of the element which can be subscribed to for changes.\r\n    \r\n    input_delay=1 //onload delay to give the children nodes enough time to get ready with their slight delays to work around the DOM a bit\r\n\r\n    //set the template string or function (which can input props to return a modified string)\r\n    template=component;\r\n\r\n    constructor() {\r\n        super();\r\n\r\n        setTimeout(\r\n            ()=> { //timeout ensures everything is on the DOM before pairing/creating graphnode objects as each is constructed sequentially and run before the next one exists\r\n                //get the child nodes from nested graph-node divs\r\n                let children = Array.from(this.children);\r\n                let top_children = [];\r\n                if(children?.length > 0) {\r\n                    children.forEach((n)=>{\r\n                        if(n.props) this.props.nodes.push(n.props.node);\r\n                        if(n.props && n.parentNode.tagName === this.tagName) top_children.push(n)\r\n                    });\r\n                }\r\n\r\n                this.children_ready(children,top_children);\r\n                \r\n            }, \r\n            this.input_delay\r\n        );\r\n    }\r\n\r\n    //like oncreate but once all of the child nodes should be loaded in the DOM, so you don't need to change the constructor\r\n    children_ready(all_children=[],top_children=[]) {\r\n        this.querySelector('button').onclick = () => { //test \r\n            top_children.forEach((c)=>{\r\n                c.props.node.runNode(c.props.node,'Test')\r\n            });\r\n        }\r\n    }\r\n\r\n    //DOMElement custom callbacks:\r\n    //oncreate=(props)=>{}\r\n    //onresize=(props)=>{} //on window resize\r\n    //onchanged=(props)=>{} //on props changed\r\n    //ondelete=(props)=>{} //on element deleted. Can remove with this.delete() which runs cleanup functions\r\n}\r\n\r\n//window.customElements.define('custom-', Custom);\r\n\r\naddCustomElement(Graph,'acyclic-graph');\r\n", "\r\nimport {DOMElement, addCustomElement} from 'fragelement';\r\n\r\nlet component = require('./sequencer.component.html');\r\n\r\n//See: https://github.com/brainsatplay/domelement\r\nexport class SeqNode extends DOMElement {\r\n    props={\r\n        operation:(input) => {\r\n            return input;\r\n        }\r\n    } //can specify properties of the element which can be subscribed to for changes.\r\n    \r\n    //set the template string or function (which can input props to return a modified string)\r\n    template=component;\r\n\r\n    //DOMElement custom callbacks:\r\n    oncreate=(props)=>{\r\n        //set up the business logic for the component\r\n        \r\n    }\r\n    //onresize=(props)=>{} //on window resize\r\n    //onchanged=(props)=>{} //on props changed\r\n    //ondelete=(props)=>{} //on element deleted. Can remove with this.delete() which runs cleanup functions\r\n}\r\n\r\n//window.customElements.define('custom-', Custom);\r\n\r\naddCustomElement(SeqNode,'snode-');\r\n", "//Simple script sequencer\r\n// Joshua Brewster AGPL v3.0\r\n\r\n// sequencer.sequences = {\r\n//     a:[{\r\n//         operation:(input)=>{},\r\n//         next:[{\r\n//             operation:(input)=>{},\r\n//             next:[\r\n//                {\r\n//                  tag:'second_layer' //tags let you subscribe to these results\r\n//                  operation:async (input)=>{},\r\n//                  delay:100,\r\n//                  async:true //can toggle if the operations should run async\r\n//                }, \r\n//                {\r\n//                  operation:async (input)=>{},\r\n//                  delay:100,\r\n//                  next:'anothersequence'\r\n//                },\r\n//                (lastResult) => {} //can input plain functions into the next sequence layers if you want just some simple one-off calls\r\n//             ]\r\n//          ]\r\n//     }],\r\n//     anothersequence:{\r\n//         //etc\r\n//     }\r\n// }\r\n\r\n\r\nexport class Sequencer {\r\n    constructor() {\r\n        this.sequences = new Map();\r\n        this.state = {\r\n            pushToState:{},\r\n            data:{},\r\n            triggers:{},\r\n            setState(updateObj){\r\n                Object.assign(this.pushToState,updateObj);\r\n        \r\n                if(Object.keys(this.triggers).length > 0) {\r\n                    // Object.assign(this.data,this.pushToState);\r\n                    for (const prop of Object.getOwnPropertyNames(this.triggers)) {\r\n                        if(this.pushToState[prop]) {\r\n                            this.data[prop] = this.pushToState[prop]\r\n                            delete this.pushToState[prop];\r\n                            this.triggers[prop].forEach((obj)=>{\r\n                                obj.onchange(this.data[prop]);\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return this.pushToState;\r\n            },\r\n            subscribeTrigger(key,onchange=(res)=>{}){\r\n                if(key) {\r\n                    if(!this.triggers[key]) {\r\n                        this.triggers[key] = [];\r\n                    }\r\n                    let l = this.triggers[key].length;\r\n                    this.triggers[key].push({idx:l, onchange:onchange});\r\n                    return this.triggers[key].length-1;\r\n                } else return undefined;\r\n            },\r\n            unsubscribeTrigger(key,sub){\r\n                let idx = undefined;\r\n                let triggers = this.triggers[key]\r\n                if (triggers){\r\n                    if(!sub) delete this.triggers[key];\r\n                    else {\r\n                        let obj = triggers.find((o)=>{\r\n                            if(o.idx===sub) {return true;}\r\n                        });\r\n                        if(obj) triggers.splice(idx,1);\r\n                        return true;\r\n                    }\r\n                }\r\n            },\r\n            subscribeTriggerOnce(key=undefined,onchange=(value)=>{}) {\r\n                let sub;\r\n                let changed = (value) => {\r\n                    onchange(value);\r\n                    this.unsubscribeTrigger(key,sub);\r\n                }\r\n\r\n                sub = this.subscribeTrigger(key,changed);\r\n            }\r\n        }\r\n    }\r\n\r\n    add(name, sequence=[]) {\r\n        this.sequences.set(name,sequence);\r\n    }\r\n\r\n    addSequence = this.add;\r\n\r\n    async run(name, input, runFromLayer=1) {\r\n        let sequence = this.sequences.get(name);\r\n        if(sequence) {\r\n            if(runFromLayer > 1) {\r\n                let i = 2;\r\n                let nextlayer = sequence.next;\r\n                while(i < runFromLayer) {\r\n                    nextlayer = nextlayer.next;\r\n                }\r\n                await this.runSequenceLayer(nextlayer, input);\r\n            }\r\n            else {\r\n                await this.runSequenceLayer(sequence, input);\r\n            }\r\n        }\r\n    }\r\n\r\n    runSequence = this.run;\r\n\r\n    appendSequence(\r\n        name, //name of sequence\r\n        layer, //layer 2 is the second layer, etc.\r\n        setting={ //object or function, functions cannot have more layers added\r\n        //operation = (result) => {} //callback for the sequence, takes the previous result\r\n        //delay:undefined, //set to a millisecond value\r\n        //async:undefined //set async:true or frame:true depending on if you want normal async or frame-timed async (which also won't run if you are out of the tab)\r\n        }, \r\n        index //append the layer .next callback from a particular index (if the layer has multiple callbacks)\r\n    ) {\r\n        let sequence = this.getSequence(name,layer);\r\n        if(sequence) {\r\n            if(!Array.isArray(sequence)) sequence = [sequence]; //make the sequence layer an array if it isn't\r\n            if(!index) sequence.push(setting);\r\n            else {\r\n                if(!sequence[index]?.next) sequence.next = [];\r\n                sequence[index]?.next.push(setting);\r\n            }\r\n        }\r\n    }\r\n\r\n    append = this.appendSequence;\r\n\r\n    removeSequence(name,layer,index) {\r\n        let sequence;\r\n        if(layer) sequence = this.getSequence(name,layer-1);\r\n        else sequence = this.getSequence(name); //get the previous layer in case we need to pop the .next variable\r\n        if(sequence) {\r\n            if(index && sequence[index]) sequence.splice(index,1);\r\n            else {\r\n                if(layer && sequence.next) {\r\n                    if(sequence.tag) this.unsubscribeFromOperation(sequence.tag);\r\n                    delete sequence.next;\r\n                }\r\n                else if(sequence) {\r\n                    this.sequences.delete(name);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    remove = this.removeSequence;\r\n\r\n    getSequence(name, layer=1) {\r\n        let sequence = this.sequences.get(name);\r\n        if(sequence) {\r\n            if(layer > 1) {\r\n                let i = 2;\r\n                let nextlayer = sequence.next;\r\n                while(i < layer) {\r\n                    if(!nextlayer.next) break;\r\n                    nextlayer = nextlayer.next;\r\n                    i++;\r\n                }\r\n                return nextlayer;\r\n            }\r\n            return sequence;\r\n        }\r\n    }\r\n\r\n    get = this.getSequence;\r\n\r\n    async runSequenceLayer(layer,previousResult) {\r\n\r\n        let run = async (o,prev,tick=1) => {\r\n\r\n            //supports different shorthand\r\n            if(o.operation) true;\r\n            else if(o.op) o.operation = o.op;\r\n            else if (o.o) o.operation = o.o;\r\n            else if (o.f) o.operation = o.f;\r\n            else if (o.fn) o.operaiion = o.fn; \r\n            else if (o.callback) o.operation = o.callback;\r\n            else return prev;\r\n\r\n            let result = await o.operation(prev);\r\n            if(o.tag) this.state.setState({[o.tag]:result});\r\n            if(typeof o.repeat === 'number') { //repeats a call with the first result\r\n                let i = tick;\r\n                while(i < o.repeat) {\r\n                    if(o.delay) {\r\n                        setTimeout(async ()=> {\r\n                            if(o.frame) {\r\n                                requestAnimationFrame(async ()=>{\r\n                                    i++;\r\n                                    await run(o,prev,i);\r\n                                });\r\n                            }\r\n                            else {\r\n                                i++\r\n                                await run(o,prev,i);\r\n                            }\r\n                        }, o.delay);\r\n                        break;\r\n                    }\r\n                    else result = await o.operation(prev);\r\n                    i++;\r\n                }\r\n                if(i === o.repeat && o.next) await this.runSequenceLayer(o.next,result);\r\n            } else if (typeof o.recursive === 'number') { //repeats a call but passes new results back in\r\n                let i = tick;\r\n                while(i < o.recursive) {\r\n                    if(o.delay) {\r\n                        setTimeout(async ()=> {\r\n                            if(o.frame) {\r\n                                requestAnimationFrame(async ()=>{\r\n                                    i++;\r\n                                    await run(o,result,i);\r\n                                });\r\n                            }\r\n                            else {\r\n                                i++\r\n                                await run(o,result,i);\r\n                            }\r\n                        }, o.delay);\r\n                        break;\r\n                    }\r\n                    else result = await o.operation(prev);\r\n                    i++;\r\n                }\r\n                if(i === o.recursive && o.next) await this.runSequenceLayer(o.next,result);\r\n            }\r\n            else if(o.next) await this.runSequenceLayer(o.next,result);\r\n        }\r\n\r\n\r\n        if(typeof layer === 'function') { await layer(previousResult); } //can set functionsi in the .next position\r\n        else if (typeof layer === 'string') { this.runSequence(layer,previousResult); } //can set sequences in the .next position by name\r\n        else if (Array.isArray(layer)) {\r\n            for(let i = 0; i < layer.length; i++) {\r\n                let o = layer[i];\r\n                if(typeof o === 'function') {\r\n                    previousResult = await o(previousResult); //if the functions are in a basic sequence this passes results along\r\n                }\r\n                else if(o.delay) { \r\n                    if (o.frame && typeof requestAnimationFrame === 'function') { //or frame-timed operations\r\n                        setTimeout(async ()=> {\r\n                            requestAnimationFrame(async ()=>{\r\n                                run(o,previousResult);\r\n                            });\r\n                        }, o.delay)\r\n                    }\r\n                    else {\r\n                        setTimeout(\r\n                            async () => {\r\n                                run(o,previousResult);\r\n                            },\r\n                            o.delay\r\n                        );\r\n                    }\r\n                }\r\n                else {\r\n                    if (o.frame) {\r\n                        requestAnimationFrame(async ()=>{\r\n                            run(o,previousResult);\r\n                        });\r\n                    }\r\n                    else {\r\n                        run(o,previousResult);\r\n                    }\r\n                }\r\n            };\r\n        } else if (typeof layer === 'object') {\r\n            run(layer,previousResult);\r\n        }\r\n    }\r\n\r\n    //subscribes to a tagged operation\r\n    subscribe(tag,callback=(result)=>{}) {\r\n        if(tag)\r\n            return this.state.subscribeTrigger(tag,callback);\r\n    }\r\n\r\n    subscribeToOperation = this.subscribe;\r\n\r\n    unsubscribe(tag, sub) {\r\n        if(tag) {\r\n            this.state.unsubscribeTrigger(tag,sub);\r\n        }\r\n    }\r\n\r\n    unsubscribeFromOperation = this.unsubscribe;\r\n\r\n}\r\n\r\n\r\nexport default Sequencer", "\r\nimport {DOMElement, addCustomElement} from 'fragelement';\r\n\r\nimport {Sequencer} from 'anothersequencer'\r\n\r\nlet component = require('./sequencer.component.html');\r\n\r\n//See: https://github.com/brainsatplay/domelement\r\nexport class SeqGraph extends DOMElement {\r\n    props={sequencer:new Sequencer(),sequences:[]} //can specify properties of the element which can be subscribed to for changes.\r\n    \r\n    //set the template string or function (which can input props to return a modified string)\r\n    template=component;\r\n\r\n    graphnode;\r\n\r\n    //DOMElement custom callbacks:\r\n    oncreate=(props)=>{\r\n        let children = this.querySelectorAll('seq-node');\r\n        if(children?.length > 0) {\r\n            children.forEach((n)=>{\r\n                props.nodes.push(n.props.node);\r\n            });\r\n        }\r\n\r\n        let topchildren = this.querySelectorAll('sequencer- > snode')\r\n\r\n        this.querySelector('button').onclick = () => {\r\n            topchildren.forEach((c)=>{\r\n                props.graph.run(c.props.node)\r\n            });\r\n        }\r\n    }\r\n\r\n    //onresize=(props)=>{} //on window resize\r\n    //onchanged=(props)=>{} //on props changed\r\n    //ondelete=(props)=>{} //on element deleted. Can remove with this.delete() which runs cleanup functions\r\n}\r\n\r\n//window.customElements.define('custom-', Custom);\r\n\r\naddCustomElement(SeqGraph,'sequencer-');\r\n", "\r\nimport {addCustomElement} from 'fragelement';\r\n\r\nimport {NodeDiv} from '../acyclicgraph/graphnode.component'\r\n\r\nlet component = require('./canvasnode.component.html');\r\n\r\n//See: https://github.com/brainsatplay/domelement\r\nexport class CanvasNodeDiv extends NodeDiv {\r\n    props={\r\n        radius:20,\r\n\r\n        operator:(\r\n            input,\r\n            node,\r\n            origin,\r\n            cmd\r\n        )=>{ \r\n\r\n            if(typeof input === 'object') {\r\n                if(input.radius) this.props.radius = input.radius;\r\n            } else {\r\n                this.props.radius += Math.random()-0.5;\r\n                if(this.props.radius <= 1) this.props.radius = 1\r\n            }\r\n\r\n            if(cmd === 'animate') {\r\n                let canvas = this.props.canvas;\r\n                let ctx = this.props.ctx;\r\n                this.drawCircle(\r\n                    canvas.height*0.5,\r\n                    canvas.width*0.5,\r\n                    this.props.radius,\r\n                    'green',\r\n                    5,\r\n                    '#003300'\r\n                );\r\n            }\r\n        },\r\n        forward:true, //pass output to child nodes\r\n        backward:false, //pass output to parent node\r\n        children:undefined, //child node(s), can be tags of other nodes, properties objects like this, or graphnodes, or null\r\n        delay:false, //ms delay to fire the node\r\n        repeat:false, // set repeat as an integer to repeat the input n times\r\n        recursive:false, //or set recursive with an integer to pass the output back in as the next input n times\r\n        animate:true, //true or false\r\n        loop:undefined, //milliseconds or false\r\n        tag:undefined, //generated if not specified, or use to get another node by tag instead of generating a new one\r\n        input:undefined,// can set on the attribute etc\r\n        graph:undefined, //parent AcyclicGraph instance, can set manually or via enclosing acyclic-graph div\r\n        node:undefined, //GraphNode instance, can set manually or as a string to grab a node by tag (or use tag)\r\n    }; //can specify properties of the element which can be subscribed to for changes.\r\n\r\n    //set the template string or function (which can input props to return a modified string)\r\n    template=component;\r\n\r\n        \r\n    drawCircle(centerX, centerY, radius, fill='green', strokewidth=5, strokestyle='#003300') {\r\n        this.props.ctx.beginPath();\r\n        this.props.ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\r\n        this.props.ctx.fillStyle = fill;\r\n        this.props.ctx.fill();\r\n        this.props.ctx.lineWidth = strokewidth;\r\n        this.props.ctx.strokeStyle = strokestyle;\r\n        this.props.ctx.stroke();\r\n    }\r\n\r\n    drawLine(\r\n        from={x:0,y:0},\r\n        to={x:1,y:1},\r\n        strokewidth=5,\r\n        strokestyle='#003300'\r\n    ) {\r\n        this.props.ctx.beginPath();\r\n        this.props.ctx.lineWidth = strokewidth;\r\n        this.props.ctx.strokeStyle = strokestyle;\r\n        this.props.ctx.moveTo(from.x, from.y);\r\n        this.props.ctx.lineTo(to.x, to.y);\r\n        this.props.ctx.stroke();\r\n    }\r\n    \r\n    //DOMElement custom callbacks:\r\n    oncreate=(props)=>{\r\n        this.canvas = this.querySelector('canvas');\r\n        if(props.width) {\r\n            this.canvas.width = props.width;\r\n            this.canvas.style.height = props.height;\r\n        }\r\n        if(props.height) {\r\n            this.canvas.height = props.height;\r\n            this.canvas.style.height = props.height;\r\n        }\r\n\r\n        props.canvas = this.canvas;\r\n        if(props.context) props.context = this.canvas.getContext(props.context);\r\n        else props.context = this.canvas.getContext('2d');\r\n        this.context = props.context;\r\n        this.ctx = this.context;\r\n        props.ctx = this.context;\r\n\r\n        setTimeout(()=>{if(props.animate) props.node.runAnimation();},10)\r\n\r\n    }\r\n\r\n    //after rendering\r\n    onresize=(props)=>{\r\n        if(props.canvas) {\r\n            props.canvas.height = this.clientHeight;\r\n            props.canvas.width = this.clientWidth;\r\n        }\r\n    } //on window resize\r\n    //onchanged=(props)=>{} //on props changed\r\n    //ondelete=(props)=>{} //on element deleted. Can remove with this.delete() which runs cleanup functions\r\n}\r\n\r\n//window.customElements.define('custom-', Custom);\r\n\r\naddCustomElement(CanvasNodeDiv,'canvas-node');\r\n", "\r\nimport {DOMElement, addCustomElement} from 'fragelement';\r\n\r\nlet component = require('./component.html');\r\n\r\n//See: https://github.com/brainsatplay/domelement\r\nexport class Custom extends DOMElement {\r\n    props={} //can specify properties of the element which can be subscribed to for changes.\r\n    \r\n    //set the template string or function (which can input props to return a modified string)\r\n    template=component;\r\n\r\n    //DOMElement custom callbacks:\r\n    oncreate=(props)=>{\r\n        //set up the business logic for the component\r\n        let button = this.querySelector('button');\r\n        let div = this.querySelector('div');\r\n        if(button) button.onclick = (ev)=>{\r\n            div.innerHTML = 'Clicked!'\r\n        };\r\n    }\r\n    //onresize=(props)=>{} //on window resize\r\n    //onchanged=(props)=>{} //on props changed\r\n    //ondelete=(props)=>{} //on element deleted. Can remove with this.delete() which runs cleanup functions\r\n}\r\n\r\n//window.customElements.define('custom-', Custom);\r\n\r\naddCustomElement(Custom,'custom-');\r\n"],
  "mappings": "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",
  "names": []
}
