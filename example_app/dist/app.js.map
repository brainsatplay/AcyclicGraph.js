{
  "version": 3,
  "sources": ["../node_modules/fragelement/DOMElement.js", "../node_modules/acyclicgraph/acyclicgraph.js", "../src/components/acyclicgraph/graphnode.component.js", "../src/components/acyclicgraph/acyclicgraph.component.js", "../src/components/sequencer/seqnode.component.js", "../src/components/sequencer/sequencer.component.js", "../src/components/component.js", "../src/app.js"],
  "sourcesContent": ["\r\nexport class DOMElement extends HTMLElement { \r\n\r\n    template = (props) => {return `<div> Custom Fragment Props: ${JSON.stringify(props)} </div>`}; //override the default template string by extending the class, or use options.template if calling the base class\r\n    props = {test:true};\r\n    \r\n    oncreate=undefined //(props) => {}  fires on element creation (e.g. to set up logic)\r\n    onresize=undefined //(props) => {} fires on window resize\r\n    ondelete=undefined //(props) => {} fires after element is deleted\r\n    onchanged=undefined //(props) => {} fires when props change\r\n\r\n    fragment = undefined;\r\n\r\n    obsAttributes=[\"props\",\"options\",\"onchanged\",\"onresize\",\"ondelete\",\"oncreate\",\"template\"]\r\n \r\n    get observedAttributes() {\r\n        return this.obsAttributes;\r\n    }\r\n\r\n    get obsAttributes() {\r\n        return this.obsAttributes;\r\n    }\r\n\r\n    set obsAttributes(att) {\r\n        if(typeof att === 'string') {\r\n            this.obsAttributes.push(att);\r\n        } else if (Array.isArray(att)) this.obsAttributes=att;\r\n    }\r\n\r\n    static get tag(){return this.name.toLowerCase()+'-'} //tagName, default 'classname-'. Set as a static variable for the internal addElement to reference\r\n\r\n    //add self or a specified class to the window which can be used via html like <custom-tag></custom-tag>\r\n    //will default be the classname with a '-' at the end if no tag supplied\r\n    static addElement(tag=this.tag,cls=this,extend=undefined) {\r\n        addCustomElement(cls,tag,extend)\r\n    }\r\n\r\n    attributeChangedCallback(name, old, val) {\r\n        if(name === 'onchanged') {\r\n            let onchanged = val;\r\n            if(typeof onchanged === 'string') onchanged = parseFunctionFromText(onchanged);\r\n            if(typeof onchanged === 'function') { \r\n                this.onchanged =  onchanged;\r\n                this.state.data.props = this.props;\r\n                this.state.unsubscribeTrigger('props'); //remove any previous subs\r\n                this.state.subscribeTrigger('props',this.onchanged);\r\n                let changed = new CustomEvent('changed', {detail: { props:this.props }});\r\n                this.state.subscribeTrigger('props',()=>{this.dispatchEvent(changed)});\r\n            }\r\n        }\r\n        else if(name === 'onresize') {\r\n            let onresize = val;\r\n            if(typeof onresize === 'string')  onresize = parseFunctionFromText(onresize);\r\n            if(typeof onresize === 'function') { \r\n                try {window.removeEventListener('resize',this.onresize);} catch(err) {}\r\n                this.onresize = onresize;\r\n                window.addEventListener('resize',this.onresize);\r\n            }\r\n        }\r\n        else if(name === 'ondelete') {\r\n            let ondelete = val;\r\n            if(typeof ondelete === 'string') ondelete = parseFunctionFromText(ondelete);\r\n            if(typeof ondelete === 'function') { \r\n                this.ondelete = () => {\r\n                    window.removeEventListener('resize',this.onresize);\r\n                    this.state.unsubscribeTrigger('props');\r\n                    ondelete();\r\n                }\r\n            }\r\n        }\r\n        else if(name === 'oncreate') { \r\n            let oncreate = val;\r\n            if(typeof oncreate === 'string') oncreate = parseFunctionFromText(oncreate);\r\n            if(typeof oncreate === 'function') { \r\n                this.oncreate = oncreate;\r\n            }\r\n        }\r\n        else if(name === 'props') { //update the props, fires any onchanged stuff\r\n            let newProps = val;\r\n            if(typeof newProps === 'string') newProps = JSON.parse(newProps);\r\n\r\n            Object.assign(this.props,newProps);\r\n            this.state.setState({props:this.props});\r\n        }\r\n        else if(name === 'template') { //change the html template\r\n\r\n            let template = val;\r\n\r\n            this.template = options.template; //function or string;\r\n\r\n            if(typeof template === 'function') this.templateString = this.template(this.props); //can pass a function\r\n            else this.templateString = template;\r\n            \r\n            //render the new template\r\n            this.render(this.props);\r\n            let created = new CustomEvent('created', {detail: { props:this.props }});\r\n            this.dispatchEvent(created);\r\n\r\n        }\r\n        else { //arbitrary attributes\r\n            let parsed = val;\r\n            if(name.includes('eval_')) { // e.g. <custom-  eval_loginput=\"(input)=>{console.log(input);}\"></custom-> //now elm.loginput(input) should work\r\n                name = name.split('_')\r\n                name.shift()\r\n                name = name.join();\r\n                parsed = parseFunctionFromText(val);  \r\n            }\r\n            else if (typeof val === 'string') {\r\n                parsed = JSON.parse(val)\r\n            }\r\n            this[name] = parsed; // set arbitrary props \r\n            this.props[name] = parsed; //reflect it in the props object (to set props via attributes more easily)\r\n            //this.props[name] = val; //set arbitrary props via attributes\r\n        }\r\n    }\r\n\r\n    connectedCallback() {\r\n\r\n        // set initial props\r\n        let newProps = this.getAttribute('props');\r\n        if(typeof newProps === 'string') newProps = JSON.parse(newProps);\r\n\r\n        Object.assign(this.props,newProps);\r\n        this.state.setState({props:this.props});\r\n\r\n\r\n        //Observe arbitrary attributes\r\n        Array.from(this.attributes).forEach((att) => {\r\n            let name = att.name;\r\n            //console.log(name,this.getAttribute(name),this[name])\r\n            if(!this[name]) { //get/set/observe arbitrary attributes\r\n                let parsed = att.value;\r\n                if(name.includes('eval_')) { // e.g. <custom-  eval_loginput=\"(input)=>{console.log(input);}\"></custom-> //now elm.loginput(input) should work\r\n                    name = name.split('_')\r\n                    name.shift()\r\n                    name = name.join();\r\n                    parsed = parseFunctionFromText(att.value);  \r\n                }\r\n                else if (typeof att.value === 'string') {\r\n                    parsed = JSON.parse(att.value)\r\n                }\r\n                Object.defineProperties(\r\n                    this, att, {\r\n                        value:parsed,\r\n                        writable:true,\r\n                        get() { return this[name]; },\r\n                        set(val) { this.setAttribute(name, val); }\r\n                    }\r\n                )\r\n                this[name] = parsed;\r\n                this.props[name] = parsed; //set on props too (e.g. to more easily modify initial conditions without stringifying an object)\r\n                this.obsAttributes.push(name);\r\n            }\r\n            \r\n            //console.log(this.observedAttributes);\r\n        })\r\n\r\n        let resizeevent = new CustomEvent('resized', {detail: { props:this.props }});\r\n        let changed = new CustomEvent('changed', {detail: { props:this.props }});\r\n        let deleted = new CustomEvent('deleted', {detail: { props:this.props }});\r\n        let created = new CustomEvent('created', {detail: { props:this.props }});\r\n        //now we can add event listeners for our custom events\r\n\r\n        this.render(this.props);\r\n        this.dispatchEvent(created);\r\n\r\n        this.state.subscribeTrigger('props',()=>{this.dispatchEvent(changed)});\r\n\r\n        if(typeof this.onresize === 'function') {\r\n            window.addEventListener('resize',()=>{\r\n                this.onresize();\r\n                this.dispatchEvent(resizeevent);\r\n            });\r\n        }\r\n\r\n        if(typeof this.ondelete === 'function') {\r\n            let ondelete = this.ondelete;\r\n            this.ondelete = () => {\r\n                window.removeEventListener('resize',this.onresize);\r\n                this.state.unsubscribeTrigger('props');\r\n                ondelete();\r\n                this.dispatchEvent(deleted);\r\n            }\r\n        }\r\n\r\n        if(typeof this.onchanged === 'function') {\r\n            this.state.data.props = this.props;\r\n            this.state.subscribeTrigger('props',this.onchanged);\r\n        }\r\n\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    get props() {\r\n        return this.props;\r\n    } \r\n\r\n    set props(newProps={}) {\r\n        this.setAttribute('props',newProps);\r\n    }\r\n\r\n    get template() {\r\n        return this.template;\r\n    } \r\n\r\n    set template(template) {\r\n        this.setAttribute('template',template);\r\n    }\r\n\r\n    get render() {\r\n        return this.render;\r\n    }\r\n\r\n    get delete() {\r\n        return this.delete;\r\n    }\r\n\r\n    get state() {\r\n        return this.state;\r\n    }\r\n\r\n    //past tense just so it can't conflict with onchange\r\n    get onchanged() {\r\n        return this.onchanged;\r\n    } \r\n\r\n    set onchanged(onchanged) {\r\n        this.setAttribute('onchanged',onchanged);\r\n    }\r\n\r\n    get onresize() {\r\n        return this.props;\r\n    } \r\n\r\n    set onresize(onresize) {\r\n        this.setAttribute('onresize',onresize);\r\n    }\r\n\r\n    get ondelete() {\r\n        return this.props;\r\n    } \r\n\r\n    set ondelete(ondelete) {\r\n        this.setAttribute('ondelete',ondelete);\r\n    }\r\n\r\n    get oncreate() {\r\n        return this.oncreate;\r\n    } \r\n\r\n    set oncreate(oncreate) {\r\n        this.setAttribute('oncreated',oncreate);\r\n    }\r\n\r\n\r\n    delete = () => { //deletes self from the DOM\r\n        this.fragment = undefined;\r\n        this.remove();\r\n        if(this.ondelete) this.ondelete(this.props);\r\n    };\r\n\r\n    render = (props=this.props) => {\r\n\r\n        if(typeof this.template === 'function') this.templateString = this.template(props); //can pass a function\r\n        else this.templateString = this.template;\r\n\r\n        //this.innerHTML = this.templateString;\r\n\r\n        const t = document.createElement('template');\r\n        t.innerHTML = this.templateString;\r\n        const fragment = t.content;\r\n        if(this.fragment) { //will reappend the fragment without reappending the whole node if already rendered once\r\n            this.removeChild(this.fragment); \r\n        }\r\n        this.fragment = fragment;\r\n        this.appendChild(fragment);\r\n        \r\n        if(this.oncreate) this.oncreate(props); //set scripted behaviors\r\n    }\r\n\r\n    state = {\r\n        pushToState:{},\r\n        data:{},\r\n        triggers:{},\r\n        setState(updateObj){\r\n            Object.assign(this.pushToState,updateObj);\r\n\r\n            if(Object.keys(this.triggers).length > 0) {\r\n                // Object.assign(this.data,this.pushToState);\r\n                for (const prop of Object.getOwnPropertyNames(this.triggers)) {\r\n                    if(this.pushToState[prop]) {\r\n                        this.data[prop] = this.pushToState[prop]\r\n                        delete this.pushToState[prop];\r\n                        this.triggers[prop].forEach((obj)=>{\r\n                            obj.onchanged(this.data[prop]);\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return this.pushToState;\r\n        },\r\n        subscribeTrigger(key,onchanged=(res)=>{}){\r\n            if(key) {\r\n                if(!this.triggers[key]) {\r\n                    this.triggers[key] = [];\r\n                }\r\n                let l = this.triggers[key].length;\r\n                this.triggers[key].push({idx:l, onchanged:onchanged});\r\n                return this.triggers[key].length-1;\r\n            } else return undefined;\r\n        },\r\n        unsubscribeTrigger(key,sub){\r\n            let idx = undefined;\r\n            let triggers = this.triggers[key]\r\n            if (triggers){\r\n                if(!sub) delete this.triggers[key];\r\n                else {\r\n                    let obj = triggers.find((o)=>{\r\n                        if(o.idx===sub) {return true;}\r\n                    });\r\n                    if(obj) triggers.splice(idx,1);\r\n                    return true;\r\n                }\r\n            }\r\n        },\r\n        subscribeTriggerOnce(key=undefined,onchanged=(value)=>{}) {\r\n            let sub;\r\n            let changed = (value) => {\r\n                onchanged(value);\r\n                this.unsubscribeTrigger(key,sub);\r\n            }\r\n\r\n            sub = this.subscribeTrigger(key,changed);\r\n        }\r\n    }\r\n}\r\n\r\n//extend the DOMElement class with an new name, this name determines the element name (always lower case in the html regardless of class name cases)\r\nexport function addCustomElement(cls, tag, extend=null) {\r\n    if(extend) {\r\n        if(tag) window.customElements.define(tag, cls, {extends:extend});\r\n        else window.customElements.define(cls.name.toLowerCase()+'-',cls, {extends:extend});\r\n    }\r\n    else {\r\n        if(tag) window.customElements.define(tag, cls);\r\n        else window.customElements.define(cls.name.toLowerCase()+'-',cls);\r\n    }\r\n}\r\n\r\nexport function randomId(tag='') {\r\n    return tag+Math.floor(Math.random()*1000000000000000);\r\n}\r\n\r\n// Proper DOM fragment implementation which also creates customElements you can use like <so></so>. High HTML5 performance via template fragments\r\nexport function parseFunctionFromText(method) {\r\n    //Get the text inside of a function (regular or arrow);\r\n    let getFunctionBody = (methodString) => {\r\n    return methodString.replace(/^\\W*(function[^{]+\\{([\\s\\S]*)\\}|[^=]+=>[^{]*\\{([\\s\\S]*)\\}|[^=]+=>(.+))/i, '$2$3$4');\r\n    }\r\n\r\n    let getFunctionHead = (methodString) => {\r\n    let startindex = methodString.indexOf(')');\r\n    return methodString.slice(0, methodString.indexOf('{',startindex) + 1);\r\n    }\r\n\r\n    let newFuncHead = getFunctionHead(method);\r\n    let newFuncBody = getFunctionBody(method);\r\n\r\n    let newFunc;\r\n    try{\r\n        if (newFuncHead.includes('function ')) {\r\n            let varName = newFuncHead.split('(')[1].split(')')[0]\r\n            newFunc = new Function(varName, newFuncBody);\r\n        } else {\r\n            if(newFuncHead.substring(0,6) === newFuncBody.substring(0,6)) {\r\n                //newFuncBody = newFuncBody.substring(newFuncHead.length);\r\n                let varName = newFuncHead.split('(')[1].split(')')[0]\r\n                //console.log(varName, newFuncHead ,newFuncBody);\r\n                newFunc = new Function(varName, newFuncBody.substring(newFuncBody.indexOf('{')+1,newFuncBody.length-1));\r\n            }\r\n            else {\r\n                try {\r\n                    newFunc = eval(newFuncHead + newFuncBody + \"}\");\r\n                } catch(err) {\r\n                    newFunc = eval(method); //try just evaluating the method\r\n                }\r\n            }\r\n        }\r\n    }\r\n    catch (err) {}\r\n\r\n    return newFunc;\r\n\r\n}\r\n\r\n", "//just a more typical hierarchical graph tree with back and forward prop and arbitrary \r\n// go-here-do-that utilities. Create an object node tree and make it do... things \r\n// same setup as sequencer but object/array/tag only (no functions), and can add arbitrary properties to mutate on objects\r\n// or propagate to children/parents with utility calls that get added to the objects\r\n//Joshua Brewster and Garrett Flynn AGPLv3.0\r\n\r\n\r\n/*\r\n\r\nlet tree = { //top level should be an object, children can be arrays of objects\r\n    tag:'top',\r\n    operator:(input,node,origin)=>{\r\n        if(typeof input === 'object') {\r\n            if(input?.x) node.x = input.x; \r\n            if(input?.y) node.y = input.y;\r\n            if(input?.z) node.z = input.z;\r\n            console.log('top node, input:', input);\r\n        }\r\n        return input;\r\n    }, //input is the previous result if passed from another node. node is 'this' node, origin is the previous node if passed\r\n    forward:true, //forward prop: returned outputs from the operator are passed to children operator(s)\r\n    //backward:true, //backprop: returned outputs from the operator are passed to the parent operator\r\n    x:3, //arbitrary properties available on the node variable in the operator \r\n    y:2,\r\n    z:1,\r\n    children:{ //object, array, or tag. Same as the 'next' tag in Sequencer.js\r\n        tag:'next', //tagged nodes get added to the node map by name, they must be unique! non-tagged nodes are only referenced internally e.g. in call trees\r\n        operator:(input,node,origin)=>{\r\n            if(origin.x) { //copy over the coordinates\r\n                node.x = origin.x;\r\n                node.y = origin.y;\r\n                node.z = origin.z;\r\n            }\r\n            console.log('next node \\n parent node:',node,'\\ninput',input);\r\n        }, // if you use a normal function operator(input,node,origin){} then you can use 'this' reference instead of 'node', while 'node' is more flexible for arrow functions etc.\r\n        //etc..\r\n        delay:500,\r\n        repeat:3\r\n    },\r\n    delay:1000//, //can timeout the operation\r\n    //frame:true //can have the operation run via requestAnimationFrame (throttling)\r\n    //repeat:3 //can repeat an operator, or use \"recursive\" for the same but passing the node's result back in\r\n};\r\n\r\n\r\nlet graph = new AcyclicGraph();\r\ngraph.addNode(tree);\r\n\r\ngraph.run(tree.tag,{x:4,y:5,z:6});\r\n\r\neach node in the tree becomes a GraphNode object\r\n\r\n*/\r\n//TODO: try to reduce the async stack a bit for better optimization, though in general it is advantageous matter as long as node propagation isn't \r\n//   relied on for absolute maximal performance concerns, those generally require custom solutions e.g. matrix math or clever indexing, but this can be used as a step toward that.\r\n\r\n//a graph representing a callstack of nodes which can be arranged arbitrarily with forward and backprop or propagation to wherever\r\nexport class AcyclicGraph {\r\n    constructor() {\r\n    \r\n        this.nodes = new Map();\r\n        this.nNodes = 0;\r\n    \r\n        this.state = {\r\n            pushToState:{},\r\n            data:{},\r\n            triggers:{},\r\n            setState(updateObj){\r\n                Object.assign(this.pushToState,updateObj);\r\n        \r\n                if(Object.keys(this.triggers).length > 0) {\r\n                    // Object.assign(this.data,this.pushToState);\r\n                    for (const prop of Object.getOwnPropertyNames(this.triggers)) {\r\n                        if(this.pushToState[prop]) {\r\n                            this.data[prop] = this.pushToState[prop]\r\n                            delete this.pushToState[prop];\r\n                            this.triggers[prop].forEach((obj)=>{\r\n                                obj.onchange(this.data[prop]);\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return this.pushToState;\r\n            },\r\n            subscribeTrigger(key,onchange=(res)=>{}){\r\n                if(key) {\r\n                    if(!this.triggers[key]) {\r\n                        this.triggers[key] = [];\r\n                    }\r\n                    let l = this.triggers[key].length;\r\n                    this.triggers[key].push({idx:l, onchange:onchange});\r\n                    return this.triggers[key].length-1;\r\n                } else return undefined;\r\n            },\r\n            unsubscribeTrigger(key,sub){\r\n                let idx = undefined;\r\n                let triggers = this.triggers[key]\r\n                if (triggers){\r\n                    if(!sub) delete this.triggers[key];\r\n                    else {\r\n                        let obj = triggers.find((o)=>{\r\n                            if(o.idx===sub) {return true;}\r\n                        });\r\n                        if(obj) triggers.splice(idx,1);\r\n                        return true;\r\n                    }\r\n                }\r\n            },\r\n            subscribeTriggerOnce(key=undefined,onchange=(value)=>{}) {\r\n                let sub;\r\n                let changed = (value) => {\r\n                    onchange(value);\r\n                    this.unsubscribeTrigger(key,sub);\r\n                }\r\n\r\n                sub = this.subscribeTrigger(key,changed);\r\n            }\r\n        }\r\n        \r\n    }\r\n    \r\n    //convert child objects to nodes\r\n    convertChildrenToNodes(n) {\r\n        n.convertChildrenToNodes(n);\r\n    }\r\n\r\n    //converts all children nodes and tag references to graphnodes also\r\n    addNode(node={}) {\r\n        let converted = new GraphNode(node,undefined,this); \r\n        return converted;\r\n    }\r\n\r\n    getNode(tag) {\r\n        return this.nodes.get(tag);\r\n    }\r\n\r\n    //Should create a sync version with no promises (will block but be faster)\r\n    run(node,input,origin) {\r\n        if(typeof node === 'string') node = this.nodes.get(node);\r\n        if(node)\r\n            return node.runNode(node,input,origin)\r\n        else return undefined;\r\n    }\r\n\r\n    removeTree(node) {\r\n        if(typeof node === 'string') node = this.nodes.get(node);\r\n        if(node) {\r\n            function recursivelyRemove(node) {\r\n                if(node.children) {\r\n                    if(Array.isArray(node.children)) {\r\n                        node.children.forEach((c)=>{\r\n                            this.nodes.delete(c.tag);\r\n                            recursivelyRemove(c);\r\n                        })\r\n                    }\r\n                    else if(typeof node.children === 'object') {\r\n                        this.nodes.delete(node.tag);\r\n                        recursivelyRemove(node);\r\n                    }\r\n                }\r\n            }\r\n            this.nodes.delete(node.tag);\r\n            recursivelyRemove(node);\r\n        }\r\n    }\r\n\r\n    removeNode(node) {\r\n        if(typeof node === 'string') node = this.nodes.get(node);\r\n        if(node) this.nodes.delete(node.tag);\r\n    }\r\n\r\n    appendNode(node={}, parentNode) {\r\n        parentNode.addChildren(node);\r\n    }\r\n\r\n    async callParent(node, input, origin=node) {\r\n        if(node?.parent) {\r\n            return await node.callParent(input, node.children, origin);\r\n        }\r\n    }\r\n\r\n    async callChildren(node, input, origin=node, idx) {\r\n        if(node?.children) {\r\n            return await node.callChildren(input, origin, idx);\r\n        }\r\n    }\r\n\r\n    subscribe(tag,callback=(res)=>{}) {\r\n        return this.state.subscribeTrigger(tag,callback);\r\n    }\r\n\r\n    unsubscribe(tag,sub) {\r\n        this.state.unsubscribeTrigger(tag,sub);\r\n    }\r\n\r\n}\r\n\r\n//the utilities in this class can be referenced in the operator after setup for more complex functionality\r\n//node functionality is self-contained, use a graph for organization\r\nexport class GraphNode {\r\n    parent;\r\n    children;\r\n    graph;\r\n\r\n    constructor(properties={}, parent, graph={}) {\r\n        if(!properties.tag && graph) properties.tag = `node${graph.nNodes}`; //add a sequential id to find the node in the tree \r\n        else if(!properties.tag) properties.tag = `node${Math.floor(Math.random()*10000000000)}`; //add a random id for the top index if none supplied\r\n        Object.assign(this,properties); //set the node's props as this\r\n        this.parent=parent;\r\n        this.graph=graph;\r\n\r\n        if(graph) {\r\n            graph.nNodes++;\r\n            graph.nodes.set(properties.tag,this);\r\n        }\r\n\r\n        if(this.children) this.convertChildrenToNodes(this);\r\n    }\r\n\r\n    //I/O scheme for this node\r\n    operator(input,node=this,origin){\r\n        return input;\r\n    }\r\n\r\n    //run the operator\r\n    async runOp(input,node=this,origin) {\r\n        let result = await this.operator(input,node, origin);\r\n        if(this.tag && this.graph) this.graph.state.setState({[this.tag]:result});\r\n        return result;\r\n    }\r\n\r\n    //runs the node sequence\r\n    //Should create a sync version with no promises (will block but be faster)\r\n    runNode(node=this,input,origin) {\r\n        if(typeof node === 'string') \r\n            {\r\n                if(!this.graph) return undefined;\r\n                node = this.graph.nodes.get(node);\r\n            }\r\n\r\n        return new Promise(async (resolve) => {\r\n            if(node) {\r\n                let run = (node, inp, tick=0) => {\r\n                    return new Promise (async (r) => {\r\n                        tick++;\r\n                        let res = await node.runOp(inp,node,origin);\r\n                        if(typeof node.repeat === 'number') {\r\n                            while(tick < node.repeat) {\r\n                                if(node.delay) {\r\n                                    setTimeout(async ()=>{\r\n                                        r(await run(node,inp,tick));\r\n                                    },node.delay);\r\n                                    break;\r\n                                } else if (node.frame && requestAnimationFrame) {\r\n                                    requestAnimationFrame(async ()=>{\r\n                                        r(await run(node,inp,tick));\r\n                                    });\r\n                                    break;\r\n                                }\r\n                                else res = await node.runOp(inp,node,origin);\r\n                                tick++;\r\n                            }\r\n                            if(tick === node.repeat) {\r\n                                r(res);\r\n                                return;\r\n                            }\r\n                        } else if(typeof node.recursive === 'number') {\r\n                            \r\n                            while(tick < node.recursive) {\r\n                                if(node.delay) {\r\n                                    setTimeout(async ()=>{\r\n                                        r(await run(node,res,tick));\r\n                                    },node.delay);\r\n                                    break;\r\n                                } else if (node.frame && requestAnimationFrame) {\r\n                                    requestAnimationFrame(async ()=>{\r\n                                        r(await run(node,res,tick));\r\n                                    });\r\n                                    break;\r\n                                }\r\n                                else res = await node.runOp(res,node,origin);\r\n                                tick++;\r\n                            }\r\n                            if(tick === node.recursive) {\r\n                                r(res);\r\n                                return;\r\n                            }\r\n                        } else {\r\n                            r(res);\r\n                            return;\r\n                        }\r\n                    });\r\n                }\r\n\r\n\r\n                let runnode = async () => {\r\n\r\n                    let res = await run(node,input); //repeat/recurse before moving on to the parent/child\r\n\r\n                    if(node.backward && node.parent) {\r\n                        await this.runNode(node.parent,res,node)\r\n                    }\r\n                    if(node.children && node.forward) {\r\n                        if(Array.isArray(node.children)) {\r\n                            for(let i = 0; i < node.children.length; i++) {\r\n                                await this.runNode(node.children[i],res,node);\r\n                            }\r\n                        }\r\n                        else await this.runNode(node.children,res,node);\r\n                    }\r\n                    \r\n                    return res;\r\n                }\r\n\r\n                if(node.delay) {\r\n                    setTimeout(async ()=>{\r\n                        resolve(await runnode());\r\n                    },node.delay);\r\n                } else if (node.frame && requestAnimationFrame) {\r\n                    requestAnimationFrame(async ()=>{\r\n                        resolve(await runnode());\r\n                    });\r\n                } else {\r\n                    resolve(await runnode());\r\n                }\r\n                \r\n            }\r\n            else resolve(undefined);\r\n        });\r\n    }\r\n\r\n    //this is the i/o handler, or the 'main' function for this node to propagate results. The origin is the node the data was propagated from\r\n    setOperator(operator=function operator(input,node=this,origin){return input;}) {\r\n        this.operator = operator;\r\n    }\r\n\r\n    setParent(parent) { \r\n        this.parent = parent;\r\n    }\r\n\r\n    addChildren(children) {\r\n        if(!Array.isArray(this.children)) this.children = [this.children];\r\n        if(Array.isArray(children)) this.children.push(...children);\r\n        else this.children.push(children);\r\n    }\r\n\r\n    convertChildrenToNodes(n=this) {\r\n        if (Array.isArray(n.children)) {\r\n            for(let i = 0; i < n.children.length; i++) {\r\n                if(n.children[i].constructor.name === this.constructor.name) continue;\r\n                n.children[i] = new GraphNode(nn,n,this.graph);\r\n                this.convertChildrenToNodes(n.children[i]);\r\n            }\r\n        }\r\n        else if(typeof n.children === 'object') {\r\n            if(n.children.constructor.name === this.constructor.name) return;\r\n            n.children = new GraphNode(n.children,n,this.graph);\r\n            this.convertChildrenToNodes(n.children);\r\n        } \r\n        else if (typeof n.children === 'string') {\r\n            n.children = this.graph.getNode(n.children);\r\n        }\r\n        return n.children;\r\n    }\r\n\r\n    //Call parent node operator directly\r\n    async callParent(input, origin=this){\r\n        if(typeof this.parent?.operator === 'function') return await this.parent.runOp(input,this.parent,origin);\r\n    }\r\n    \r\n    async callChildren(input, origin=this, idx){\r\n        let result;\r\n        if(Array.isArray(this.children)) {\r\n            if(idx) result = await this.children[idx]?.runOp(input,this.children[idx],origin);\r\n            else {\r\n                result = [];\r\n                for(let i = 0; i < this.children.length; i++) {\r\n                    result.push(await this.children[idx]?.runOp(input,this.children[idx],origin));\r\n                } \r\n            }\r\n        } else if(this.children) {\r\n            result = await this.children.runOp(input,this.children,origin);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    setProps(props={}) {\r\n        Object.assign(this,props);\r\n    }\r\n\r\n}\r\n\r\n// exports.AcyclicGraph = AcyclicGraph;\r\n// exports.GraphNode = GraphNode;\r\n\r\n", "\r\nimport {DOMElement, addCustomElement} from 'fragelement';\r\n\r\nimport {GraphNode} from 'acyclicgraph'\r\n\r\nlet component = require('./graphnode.component.html');\r\n\r\n//See: https://github.com/brainsatplay/domelement\r\nexport class NodeDiv extends DOMElement {\r\n    props={\r\n        tag:undefined,\r\n        input:undefined,\r\n        operator:(input,node,origin)=>{ console.log(input); return input; },\r\n        forward:true,\r\n        backward:false,\r\n        children:undefined,\r\n        delay:false,\r\n        repeat:false, // set repeat \r\n        recursive:false,\r\n        graph:undefined, //parent AcyclicGraph instance\r\n        node:undefined, //GraphNode instance\r\n    }; //can specify properties of the element which can be subscribed to for changes.\r\n    \r\n    //set the template string or function (which can input props to return a modified string)\r\n    template=component;\r\n\r\n    //DOMElement custom callbacks:\r\n    oncreate=(props)=>{\r\n        this.setupNode(props)\r\n\r\n        if(props.input) { //e.g. run the node on input\r\n            props.node.runNode(props.node,props.input,undefined);\r\n        }\r\n    }\r\n\r\n    setupNode(props) {\r\n        if(!props.graph) {\r\n            let parent = this.parentNode;\r\n            if(parent.constructor.name === 'NodeDiv') {\r\n                props.parent = parent.node;\r\n            }\r\n            while(parent?.constructor.name !== 'AcyclicGraph') {\r\n                if(parent.constructor.name === 'HTMLBodyElement' || parent.constructor.name === 'HTMLHeadElement' || parent.constructor.name === 'HTMLHtmlElement' || parent.constructor.name === 'HTMLDocument') {\r\n                    console.error(\"No AcyclicGraph Found, error\")\r\n                    break;\r\n                }\r\n                parent = parent.parentNode;\r\n            }\r\n            if(parent.constructor.name === 'AcyclicGraph') {\r\n                props.graph = parent.props.graph;\r\n            }\r\n        }\r\n        if(this.id && !props.tag) props.tag = this.id;\r\n\r\n        props.node = new GraphNode(props, parent.node, props.graph);\r\n\r\n        props.tag = props.node.tag;\r\n       \r\n        if(!this.id) this.id = props.tag;\r\n\r\n    }\r\n    //onresize=(props)=>{} //on window resize\r\n    //onchanged=(props)=>{} //on props changed\r\n    //ondelete=(props)=>{} //on element deleted. Can remove with this.delete() which runs cleanup functions\r\n}\r\n\r\n//window.customElements.define('custom-', Custom);\r\n\r\naddCustomElement(NodeDiv,'graph-node');\r\n", "\r\nimport {DOMElement, addCustomElement} from 'fragelement';\r\n\r\nimport {AcyclicGraph} from 'acyclicgraph'\r\n\r\nlet component = require('./acyclicgraph.component.html');\r\n\r\n//See: https://github.com/brainsatplay/domelement\r\nexport class Graph extends DOMElement {\r\n    props={graph:new AcyclicGraph(),nodes:[]} //can specify properties of the element which can be subscribed to for changes.\r\n    \r\n    //set the template string or function (which can input props to return a modified string)\r\n    template=component;\r\n\r\n    graphnode;\r\n\r\n    //DOMElement custom callbacks:\r\n    oncreate=(props)=>{\r\n        let children = this.querySelectorAll('graph-node');\r\n        if(children?.length > 0) {\r\n            children.forEach((n)=>{\r\n                props.nodes.push(n.props.node);\r\n            });\r\n        }\r\n\r\n        let topchildren = this.querySelectorAll('acyclic-graph > graph-node')\r\n\r\n        this.querySelector('button').onclick = () => {\r\n            topchildren.forEach((c)=>{\r\n                c.props.node.runNode(c.props.node)\r\n            });\r\n        }\r\n    }\r\n\r\n    //onresize=(props)=>{} //on window resize\r\n    //onchanged=(props)=>{} //on props changed\r\n    //ondelete=(props)=>{} //on element deleted. Can remove with this.delete() which runs cleanup functions\r\n}\r\n\r\n//window.customElements.define('custom-', Custom);\r\n\r\naddCustomElement(Graph,'acyclic-graph');\r\n", "\r\nimport {DOMElement, addCustomElement} from 'fragelement';\r\n\r\nlet component = require('./sequencer.component.html');\r\n\r\n//See: https://github.com/brainsatplay/domelement\r\nexport class SeqNode extends DOMElement {\r\n    props={\r\n        operation:(input) => {\r\n            return input;\r\n        }\r\n    } //can specify properties of the element which can be subscribed to for changes.\r\n    \r\n    //set the template string or function (which can input props to return a modified string)\r\n    template=component;\r\n\r\n    //DOMElement custom callbacks:\r\n    oncreate=(props)=>{\r\n        //set up the business logic for the component\r\n        \r\n    }\r\n    //onresize=(props)=>{} //on window resize\r\n    //onchanged=(props)=>{} //on props changed\r\n    //ondelete=(props)=>{} //on element deleted. Can remove with this.delete() which runs cleanup functions\r\n}\r\n\r\n//window.customElements.define('custom-', Custom);\r\n\r\naddCustomElement(SeqNode,'snode-');\r\n", "\r\nimport {DOMElement, addCustomElement} from 'fragelement';\r\n\r\nimport {Sequencer} from 'anothersequencer'\r\n\r\nlet component = require('./sequencer.component.html');\r\n\r\n//See: https://github.com/brainsatplay/domelement\r\nexport class SeqGraph extends DOMElement {\r\n    props={sequencer:new Sequencer(),sequences:[]} //can specify properties of the element which can be subscribed to for changes.\r\n    \r\n    //set the template string or function (which can input props to return a modified string)\r\n    template=component;\r\n\r\n    graphnode;\r\n\r\n    //DOMElement custom callbacks:\r\n    oncreate=(props)=>{\r\n        let children = this.querySelectorAll('seq-node');\r\n        if(children?.length > 0) {\r\n            children.forEach((n)=>{\r\n                props.nodes.push(n.props.node);\r\n            });\r\n        }\r\n\r\n        let topchildren = this.querySelectorAll('sequencer- > snode')\r\n\r\n        this.querySelector('button').onclick = () => {\r\n            topchildren.forEach((c)=>{\r\n                props.graph.run(c.props.node)\r\n            });\r\n        }\r\n    }\r\n\r\n    //onresize=(props)=>{} //on window resize\r\n    //onchanged=(props)=>{} //on props changed\r\n    //ondelete=(props)=>{} //on element deleted. Can remove with this.delete() which runs cleanup functions\r\n}\r\n\r\n//window.customElements.define('custom-', Custom);\r\n\r\naddCustomElement(Graph,'sequencer-');\r\n", "\r\nimport {DOMElement, addCustomElement} from 'fragelement';\r\n\r\nlet component = require('./component.html');\r\n\r\n//See: https://github.com/brainsatplay/domelement\r\nexport class Custom extends DOMElement {\r\n    props={} //can specify properties of the element which can be subscribed to for changes.\r\n    \r\n    //set the template string or function (which can input props to return a modified string)\r\n    template=component;\r\n\r\n    //DOMElement custom callbacks:\r\n    oncreate=(props)=>{\r\n        //set up the business logic for the component\r\n        let button = this.querySelector('button');\r\n        let div = this.querySelector('div');\r\n        if(button) button.onclick = (ev)=>{\r\n            div.innerHTML = 'Clicked!'\r\n        };\r\n    }\r\n    //onresize=(props)=>{} //on window resize\r\n    //onchanged=(props)=>{} //on props changed\r\n    //ondelete=(props)=>{} //on element deleted. Can remove with this.delete() which runs cleanup functions\r\n}\r\n\r\n//window.customElements.define('custom-', Custom);\r\n\r\naddCustomElement(Custom,'custom-');\r\n", "import './components/components.index'\r\n\r\nlet elm = document.createElement('custom-');\r\n\r\nconsole.log('custom element:', elm, elm.__proto__);\r\n\r\n\r\n\r\n"],
  "mappings": "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",
  "names": []
}
